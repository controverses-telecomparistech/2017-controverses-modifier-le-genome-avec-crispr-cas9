<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>WebGL model renderer</title>
    <script src="three.min.js"></script>
    <script src="ConnectorSegments.js"></script>
    <style>
      body { margin:0; background-image:url("background.png"); }
      canvas { width:100%; height:100%; }
    </style>
  </head>
  <body>
    <script type="text/javascript">
      // Code du rendu 3D
      var renderer, scene, camera, mesh;
      var raycaster = new THREE.Raycaster(); // pour détecter quel objet est sous la souris
      var dialogBoxes = [], segments = []; // pour maintenir les ConnectorSegments et les mettre à jour
      // Constantes pour la taille des boîtes cliquables
      var box_width = 40, box_height = 10, box_depth = -75;
      var box_bgcolor = 0x444444;
      // Constate de la vitesse de rotation
      var BOX_ROTATION_SPEED = 0.01;
      
      initScene();
      animate();
      
      function initScene()
      {
        // Moteur de rendu de three.js
        renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        
        // Scène 3D dans laquelle on va mettre tous les objets
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 1000);
        camera.position.z = 10;
        scene.add(camera);
        
        // Une source de lumière
        var dirLight = new THREE.DirectionalLight(0xffffff, 0.95);
        dirLight.position.set(-3, 3, 7);
        dirLight.position.normalize();
        scene.add(dirLight);
        
        // Voire deux, pourquoi pas
        var pointLight = new THREE.PointLight(0xffffff, 5, 50);
        pointLight.position.set(10, 20, -10);
        scene.add(pointLight);
        
        // Ajout du gros modèle 3D d'ADN
        // ! Le chargement est asynchrone !
        var jsonLoader = new THREE.JSONLoader();
        jsonLoader.load("dna.json", function(geometry, materials)
          {
            mesh = new THREE.Mesh(geometry, materials[0]);
            mesh.rotation.order = "ZXY";
            mesh.rotation.z = 0.5;
            mesh.position.z = -100; // distance respectable, c'est que le modèle est plutôt gros
            // setupControls();
            scene.add(mesh);
          });
        
        // Ajout de quelques boîtes cliquables pour les liens des pages
        // Boîte
        var geom = new THREE.PlaneGeometry(box_width, box_height);
        // Contour de la boîte
        var outline_geom = new THREE.Geometry();
        outline_geom.vertices.push(new THREE.Vector3(-box_width / 2, box_height / 2, 0));
        outline_geom.vertices.push(new THREE.Vector3(box_width / 2, box_height / 2, 0));
        outline_geom.vertices.push(new THREE.Vector3(box_width / 2, -box_height / 2, 0));
        outline_geom.vertices.push(new THREE.Vector3(-box_width / 2, -box_height / 2, 0));
        outline_geom.vertices.push(new THREE.Vector3(-box_width / 2, box_height / 2, 0));
        var outline_mat = new THREE.LineBasicMaterial({color:0x4286f4, linewidth:5});
        
        // On construit les Mesh des boîtes
        // On va afficher le texte sur un canvas qui sera ensuite utilisé comme texture par la boîte
        var frustum = new THREE.Frustum(); // limites du champ de vision
        frustum.setFromMatrix(camera.projectionMatrix);
        var canvas = document.createElement("canvas");
        canvas.width = box_width;
        canvas.height = box_height;
        var ctx = canvas.getContext("2d");
        ctx.font = "30px Courier";
        for(var i = 0; i < 3; i++)
        {
          dialogBoxes[i] = new THREE.Group()
          // Fond gris
          ctx.fillStyle = "#444444";
          ctx.fillRect(0, 0, box_width, box_height);
          
          // Les noms de toutes les boîtes commencent par "box" pour les retrouver plus tard
          var mat = new THREE.MeshBasicMaterial({map:new THREE.CanvasTexture(canvas), side:THREE.DoubleSide});
          var m = new THREE.Mesh(geom, mat);
          m.name = "Box " + (i + 1);
          dialogBoxes[i].add(m);
          dialogBoxes[i].add(new THREE.Line(outline_geom, outline_mat));
          // On place la boîte au hasard dans le champ de vision de la caméra
          var p = new THREE.Vector3();
          do
          {
            // léger écart en profondeur pour que les boîtes se chevauchent
            p.set(Math.random() * 30 - 15, Math.random() * 30  - 15 + (i - 1) * 50, box_depth - i);
          } while(!frustum.containsPoint(p) || !frustum.containsPoint(p.clone().add(20, 5, 0)));
          dialogBoxes[i].position.set(p.x, p.y, p.z);
          scene.add(dialogBoxes[i]);
        }
        // On fait en sorte que les boîtes réagissent au clic
        renderer.domElement.addEventListener("mouseup", mouseup);
        
        // Appelé quand l'utilisateur relâche le clic gauche
        function mouseup(event)
        {
          if(event.button == 0)
          {
            var mouse = new THREE.Vector2();
            mouse.x = event.clientX / window.innerWidth * 2. - 1.;
            mouse.y = -event.clientY / window.innerHeight * 2. + 1.;
            raycaster.setFromCamera(mouse, camera);
            // Test récursif sur les boîtes uniquement (objets dont les noms commencent par "Box")
            var intersects = raycaster.intersectObjects(dialogBoxes.map(group => group.children.filter(obj => obj.name.split(" ")[0] == "Box")[0]), true);
            if(intersects.length > 0)
              alert(intersects[0].object.name);
          }
        }
      }
      
      // Fonction appelée à chaque rafraîchissement d'écran
      function animate()
      {
        requestAnimationFrame(animate);
        // On attend que le modèle 3D soit chargé (chargement asynchrone)
        if(mesh)
        {
          // Petite rotation des familles
          mesh.rotation.y += BOX_ROTATION_SPEED;
          // On initialise les ConnectorSegments s'il le faut
          if(segments.length < 1)
          {
            for(var i = 0; i < dialogBoxes.length; i++)
            {
              var target = new THREE.Vector3(0, (i - 1) * 50, -100);
              target.applyEuler(mesh.rotation);
              segments[i] = new ConnectorSegments(dialogBoxes[i], target, 0);
              segments[i].object.rotation.order = mesh.rotation.order;
              dialogBoxes[i].add(segments[i].object);
            }
          }
          // Il y a autant de ConnectorSegments que de dialogBoxes
          for(var i = 0; i < dialogBoxes.length; i++)
          {
            dialogBoxes[i].position.sub(segments[i].target);
            dialogBoxes[i].position.applyEuler(new THREE.Euler(0., BOX_ROTATION_SPEED, 0.));
            dialogBoxes[i].position.add(segments[i].target);
            segments[i].update();
          }
        }
        render();
      }
      
      function render()
      {
        camera.lookAt(scene.position);
        renderer.render(scene, camera);
      }
    </script>
    
    <!-- Le texte des trois boîtes de dialogue sont dans des divs invisibles -->
    <a href="article1.html" class="dialogText" id="dialog1" hidden>
    Ceci est l'article 1 ! Cliquez sur moi !
    </div>
    <a href="article2.html" class="dialogText" id="dialog2" hidden>
    Ceci est l'article 2 ! Cliquez plutôt sur moi,\n je suis bien mieux !
    </div>
    <a href="article3.html" class="dialogText" id="dialog3" hidden>
    Ceci est l'article 3 ! Je suis de loin le\nmeilleur article !
    </div>
  </body>
</html>
