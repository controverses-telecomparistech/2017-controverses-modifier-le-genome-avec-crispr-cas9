<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>WebGL model renderer</title>
    <script src="three.min.js"></script>
    <script src="ConnectorSegments.js"></script>
    <style>
      body { margin:0; }
      canvas { width:100%; height:100%; }
    </style>
  </head>
  <body>
    <script type="text/javascript">
      // Code du rendu 3D
      var renderer, scene, camera, mesh;
      var raycaster = new THREE.Raycaster(); // pour détecter quel objet est sous la souris
      var dialogBoxes = [], segments = []; // pour maintenir les ConnectorSegments et les mettre à jour
      // Constantes pour la taille des boîtes cliquables
      var box_width = 40, box_height = 10, box_depth = -75;
      var box_bgcolor = 0x444444;
      
      initScene();
      animate();
      
      function initScene()
      {
        renderer = new THREE.WebGLRenderer({ antialias:true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 1000);
        camera.position.z = 10;
        scene.add(camera);
        
        var dirLight = new THREE.DirectionalLight(0xffffff, 0.95);
        dirLight.position.set(-3, 3, 7);
        dirLight.position.normalize();
        scene.add(dirLight);
        
        var pointLight = new THREE.PointLight(0xffffff, 5, 50);
        pointLight.position.set(10, 20, -10);
        scene.add(pointLight);
        
        // Ajout d'un fond étoilé
        var starsGeometry = new THREE.Geometry();

        for(var i = 0; i < 10000; i++)
        {

          starsGeometry.vertices.push(new THREE.Vector3(
            THREE.Math.randFloatSpread(2000),
            THREE.Math.randFloatSpread(2000),
            THREE.Math.randFloatSpread(2000))
          );
        }
        
        var starsMaterial = new THREE.PointsMaterial({ color:0x888888 });
        var starField = new THREE.Points(starsGeometry, starsMaterial);
        scene.add(starField);
        
        // Ajout du gros modèle 3D d'ADN
        var jsonLoader = new THREE.JSONLoader();
        jsonLoader.load("dna.json", function(geometry, materials)
          {
            mesh = new THREE.Mesh(geometry, materials[0]);
            mesh.rotation.order = "ZXY";
            mesh.rotation.z = 0.5;
            mesh.position.z = -100; // distance respectable, c'est que le modèle est plutôt gros
            // setupControls();
            scene.add(mesh);
          });
        
        // Ajout de quelques boîtes cliquables pour les liens des pages
        // Boîte
        var geom = new THREE.PlaneGeometry(box_width, box_height);
        // Contour de la boîte
        var outline_geom = new THREE.Geometry();
        outline_geom.vertices.push(new THREE.Vector3(-box_width / 2, box_height / 2, 0));
        outline_geom.vertices.push(new THREE.Vector3(box_width / 2, box_height / 2, 0));
        outline_geom.vertices.push(new THREE.Vector3(box_width / 2, -box_height / 2, 0));
        outline_geom.vertices.push(new THREE.Vector3(-box_width / 2, -box_height / 2, 0));
        outline_geom.vertices.push(new THREE.Vector3(-box_width / 2, box_height / 2, 0));
        // var mat = new THREE.MeshBasicMaterial({color:0x444444, side: THREE.DoubleSide});
        var outline_mat = new THREE.LineBasicMaterial({color:0x4286f4, linewidth:5});
        var frustum = new THREE.Frustum();
        frustum.setFromMatrix(camera.projectionMatrix);
        // On construit les Mesh des boîtes
        // On va afficher le texte sur un canvas qui sera ensuite utilisé comme texture
        var canvas = document.createElement("canvas");
        canvas.width = box_width;
        canvas.height = box_height;
        var ctx = canvas.getContext("2d");
        ctx.font = "30px Courier";
        for(var i = 0; i < 3; i++)
        {
          dialogBoxes[i] = new THREE.Group()
          ctx.fillStyle = "#444444";
          ctx.fillRect(0, 0, box_width, box_height);
          
          var mat = new THREE.MeshBasicMaterial({map:new THREE.CanvasTexture(canvas), side:THREE.DoubleSide});
          var m = new THREE.Mesh(geom, mat);
          m.name = "Box " + (i + 1);
          dialogBoxes[i].add(m);
          dialogBoxes[i].add(new THREE.Line(outline_geom, outline_mat));
          var p = new THREE.Vector3();
          do
          {
            
            // léger écart en profondeur pour que les boîtes se chevauchent
            p.set(Math.random() * 100 - 50, Math.random() * 100 - 50, box_depth - i);
          } while(!frustum.containsPoint(p) || !frustum.containsPoint(p.clone().add(20, 5, 0)));
          dialogBoxes[i].position.set(p.x, p.y, p.z);
          scene.add(dialogBoxes[i]);
        }
        // On fait en sorte que les boîtes réagissent au clic
        renderer.domElement.addEventListener("mouseup", mouseup);
        
        function mouseup(event)
        {
          if(event.button == 0)
          {
            var mouse = new THREE.Vector2();
            mouse.x = event.clientX / window.innerWidth * 2. - 1.;
            mouse.y = -event.clientY / window.innerHeight * 2. + 1.;
            raycaster.setFromCamera(mouse, camera);
            var intersects = raycaster.intersectObjects(dialogBoxes.map(group => group.children.filter(obj => obj.name.split(" ")[0] == "Box")[0]), true); // test récursif sur les descendants des objets
            if(intersects.length > 0)
              alert(intersects[0].object.name);
          }
        }
      }
      
      function animate()
      {
        requestAnimationFrame(animate);
        if(mesh)
        {
          mesh.rotation.y += 0.02;
          if(segments.length < 1)
          {
            for(var i = 0; i < dialogBoxes.length; i++)
            {
              var target = new THREE.Vector3(0, (i - 1) * 50, -100);
              target.applyEuler(mesh.rotation);
              segments[i] = new ConnectorSegments(dialogBoxes[i], target);
              dialogBoxes[i].add(segments[i].object);
            }
          }
        }
        render();
      }
      
      function render()
      {
        camera.lookAt(scene.position);
        renderer.render(scene, camera);
      }
    </script>
    
    <!-- Le texte des trois boîtes de dialogue sont dans des divs invisibles -->
    <div class="dialogText" id="dialog1" hidden>
    Ceci est l'article 1 ! Cliquez sur moi !
    </div>
    <div class="dialogText" id="dialog2" hidden>
    Ceci est l'article 2 ! Cliquez plutôt sur moi,\n je suis bien mieux !
    </div>
    <div class="dialogText" id="dialog3" hidden>
    Ceci est l'article 3 ! Je suis de loin le\nmeilleur article !
    </div>
  </body>
</html>
